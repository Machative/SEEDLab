In this project we worked to incorporate everyones roles in the team to detect a marker with a camera and find where in the camera frame that marker is.
The position of the marker is categorized to one of four quadrants of the screen. The quadrant information is sent over I2C to an Arduino which interprets the quadrant into a rotational position. The Arduino drives a motor to rotate to that position using a feedback control loop.

FinalArduinoCode.ino contains all of the code for the Arduino. The Arduino attaches to a motor shield to drive the motor. The Arduino regularly receives a value between 1 and 4 from the Raspberry Pi over I2C communication based on the current location of the Aruco marker. These values each indicate a position to which the motor should rotate (1 = 0 radians, 2 = PI/2 radians, 3 = PI radians, 4 = 3PI/2 radians). When a desired position is known, the motor is driven to that position using a generic PID controller. In this application however, the I and D terms were not needed and so were set to zero. This is because the system is essentially a first-order system with little mass and lots of natural damping. Finally, the Arduino sends back the current precise position of the motor, in radians, over the I2C bus as block data back to the Raspberry Pi , so that the Pi can display the desired and current position on the LCD screen.

The marker is detected using the miniProject_detection.py file. This file uses OpenCV and numpy to check for any markers in the frame read in by a camera. From the data gathered from any markers detected, the program then finds the average x and y coordinates of the center of the marker. From those averages of the center of the marker, it is then able to compare those coordinates with the resolution of the frame being read in, to find which quadrant the center of the marker appears in. Then, the systems integration specialist is able to send data over I2C to the arduino about the location of the marker.

The motorTunedStep.ino is a program used for the purpose of collecting data from the motor with the closed loop PI feedback control in place on the motor via code on the Arduino program motorTunedStep.ino. It starts a motor step response with respect to velocity at 1 second, and then stops this step at 3 seconds, via instituting a feedback control that takes the difference between the desired displacement, which is a ramp function for t = 1 to t = 4 seconds, and the current displacement. This error then has a backward difference applied to it to simulate a derivative, and is multiplied by the time since the corresponding code last ran and added to a running sum to mimic integration. The PI control scheme then acts on these errors and applies a voltage to the motor to correct the errors by rotating the motor accordingly and in the right direction. Data from the serial monitor is received by the Arduino by serial print statements executed by the code returning the velocity, current runtime in ms, and motor logic. Lastly, a while loop designed to ensure a 5 ms time period between serial prints is executed. 

The SEED_Lab_miniproject_4_6.ino is a program used for the purpose of collecting data from the motor with no feedback control in place on the motor via code on the Arduino program motorTunedStep.ino. It starts a motor step response with respect to velocity at 1 second, and then stops this step at 2 seconds, via instituting a motor logic command to either have 0 V applied or full voltage applied depedning on the time. Data from the serial monitor is then received by the Arduino by serial print statements executed by the code returning the velocity, current runtime in ms, and motor logic. Lastly, a while loop designed to ensure a 5 ms time period between serial prints is executed. 

PI parameters is a .txt file listing the Kp and Ki values found via MATLAB and Simulink simulation.
